**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#4 – Mutation Testing and Web app testing**

| Group: Group Number   28  |
|-----------------|
| Student 1 name:   Ahmad Janjua        |   
| Student 2 name:   Maxwell Kepler      |   
| Student 3 name:   Christopher Luk     |   
| Student 4 name:   Matthew Ho          | 

[1 Introduction	](#introduction)

[2 Analysis of 10 Mutants of the Range class](#analysis-of-10-mutants-of-the-range-class)

[3 Report all the statistics and the mutation score for each test class](#report-all-the-statistics-and-the-mutation-score-for-each-test-class)

[4 Analysis drawn on the effectiveness of each of the test classes	](#analysis-drawn-on-the-effectiveness-of-each-of-the-test-classes)

[5 A discussion on the effect of equivalent mutants on mutation score accuracy](#a-discussion-on-the-effect-of-equivalent-mutants-on-mutation-score-accuracy))

[6 A discussion of what could have been done to improve the mutation score of the test suites	](#a-discussion-of-what-could-have-been-done-to-improve-the-mutation-score-of-the-test-suites)

[7 Why do we need mutation testing? Advantages and disadvantages of mutation testing](#why-do-we-need-mutation-testing-advantages-and-disadvantages-of-mutation-testing)


[8 Explain your SELENUIM test case design process](#explain-your-selenuim-test-case-design-process)

[9 Explain the use of assertions and checkpoints](#explain-the-use-of-assertions-and-checkpoints)

[10 how did you test each functionaity with different test data](#how-did-you-test-each-functionaity-with-different-test-data)

[11 Discuss advantages and disadvantages of Selenium vs. Sikulix.](#discuss-advantages-and-disadvantages-of-selenium-vs-sikulix)

[12 How the team work/effort was divided and managed](#how-the-team-workeffort-was-divided-and-managed)

[13 Difficulties encountered, challenges overcome, and lessons learned](#difficulties-encountered-challenges-overcome-and-lessons-learned)

[14 Comments/feedback on the lab itself](#commentsfeedback-on-the-lab-itself)



# Introduction

# Analysis of 10 Mutants of the Range class 

# Report all the statistics and the mutation score for each test class



**DataUtilities:** 

**Initial PIT Test Coverage:**


**2.5.6:**

**How a few equivalent mutants in the experiment can be detected automatically:**

With consideration of the tools that can be used to automate the testing of detecting equivalent mutants, machine learning algorithms can be used. To detect equivalent mutants using machine learning we have to look at the mutation logs and determine where and what mutations were made in order to help the machine learning model tell the difference between equivalent and non-equivalent mutants. Next, we need to get a bunch of mutants and decide if they are equivalent or not, moreover labeling the mutants.  We then use these labeled mutants to teach the machine learning model how to tell the difference between equivalent and non-equivalent mutants. After that, we train the machine learning model using the labeled mutants. This means we teach the model how to use the features we picked out to tell the difference between equivalent and non-equivalent mutants. Once the model is trained, we test it to see how well it can tell the difference between equivalent and non-equivalent mutants. If it works well, we can use it to automatically detect equivalent mutants in new code. This will help developers focus on the most important mutants.

**Benefits:**
The general benefit of using machine learning instead of manually finding equivalent mutants is that it generally saves time and effort. Additionally, there may be a lot of human error that can be made especially when it comes to looking over a large log that contains thousands of lines to process and examine. Since machine learning can learn patterns better than humans, it can potentially identify more equivalent mutants overall.   

**Disadvantages:**
The disadvantage of using machine learning would be the amount of labeling that has to be done to train the machine learning model to be able to determine what is equivalent and what is not. Additionally, if there are complex mutants, then the machine learning algorithm may falsely identify it. 

**Assumptions: **
An assumption of using machine learning is that the extraction and labeling process of training the machine learning algorithm is done correctly as those processes allow the model to be able to distinguish patterns and analyze data. If these processes are done incorrectly, then the model’s performance will be greatly impacted. 

**Manually Detecting Equivalent Mutants:**
Within the process of manually detecting equivalent mutants, we first begin looking at the logs and at which mutants survived and which ones were killed as finding equivalent mutants involves finding the mutants that survived that do not change the behavior of the program.

**Example within DataUtilities**
Within the for loop within line 104, since the terminating condition is when i = souce.length, an equivalent mutant would be when i != source.length instead of i < source.length since the logic is still the same

**Pit Test Coverage Results**

 
**Discuss in your report the test cases that you had to add to increase the mutation score, and also how you designed them.**

The way that the mutation coverage score was increased by 10% was by commenting out code that was asking for invalid inputs within the source code. An example would be within the calculateColumnTotal method within line 133 as the for loop is saying that r2=0 and the condition is when r2 > rowCount therefore the rowCount is less than zero. Since we are asking for an invalid input within the calculateColumnTotal method, the for loop is trying to iterate through the rows of the table and sum up the values in a specific column. However, the loop is set up in such a way that it will never execute if the rowCount is less than or equal to zero as an IndexOutOfBoundsError. With that in consideration, the mutants are not reachable if the portion of the code exists and must be commented out for them to be reachable. After removing it, we noticed substantial mutation coverage as it went from 73% to 83%.

# Analysis drawn on the effectiveness of each of the test classes

# A discussion on the effect of equivalent mutants on mutation score accuracy

# A discussion of what could have been done to improve the mutation score of the test suites
Within the lab, we determined from our experimental process that to improve the mutation score of the test suites. First, we need to make the test cases more robust by ensuring that they cover all possible scenarios, such as edge cases and boundary conditions. Additionally, we need to look at the source code to determine areas that would never be reached by the mutants. This can be done by either removing the unreachable code or adding new test cases that cover these areas to improve the mutation score. By examining these areas highlighted by the Pit Test, we were able to determine where we needed to add coverage. This helped us to create more effective test cases and improve the overall mutation score of the test suites. Overall, by combining these approaches and continuously refining the test suite, we can achieve a higher level of confidence in the quality and robustness of our software.

# Why do we need mutation testing? Advantages and disadvantages of mutation testing
The reason why we need mutation testing is because it allows for the detection of faults in the code by testing small changes within the code. As a result of mutation testing, the quality, reliability and effectiveness of the software is greatly improved as these tests aim to evaluate areas of the code that require adjustments and improvements, while also confirming the quality of other areas.

Advantages of mutation testing helps identify areas of the test cases that may be weak within the test suite. By doing so, testers can make adjustments to ensure that the weak areas within the test suite are improved such that the overall quality of the software is improved.

Disadvantages of mutation testing is that when it comes to larger applications, it may be very resource intensive. When running the pit test on less powerful machines, it took some members up to 25 minutes to run the Pit Test. If the software was larger and had more tests, it would require more resources as large-scale software would be difficult to run for those who do not have the resources to do so. As a result, mutation testing is not accessible to everyone. 

# Explain your SELENUIM test case design process

# Explain the use of assertions and checkpoints

# how did you test each functionaity with different test data

# Discuss advantages and disadvantages of Selenium vs. Sikulix

# How the team work/effort was divided and managed
During the mutation testing assignment, the team divided the work and managed their efforts effectively. The team was divided into two pairs as they were comfortable working together. They assigned tasks based on what each member wanted to do. To manage their workflow, the team used a Google doc to document their work before putting it into a GitHub repository. Additionally, they used an online chat to discuss things in real-time. Overall, the team worked collaboratively and efficiently to complete the assignment.

# Difficulties encountered, challenges overcome, and lessons learned

# Comments/feedback on the lab itself
Within the lab, the team found the mutation testing portion to be quite challenging and time-consuming. The large size of the test suite made it impractical to run the Pit Test in a reasonable amount of time, often taking up to 15-8 minutes to complete. This was a frustrating experience, and it would have been helpful if a smaller and more focused test suite was provided. However, despite this challenge, the team appreciated the opportunity to learn about mutation testing and the importance of test coverage. Overall, the lab was a valuable learning experience, but it would have been helpful to have more efficient tools for testing.
